
# Bomb Lab

`bomb.tar`中提供了如下文件:

- `bomb` (二进制可执行文件)
- `bomb.c` (bomb的C程序文件)
- `README`

尝试直接运行可执行文件`./bomb`，结果直接就炸了，还是从C程序文件读起吧。

![bomb.c](./pic/sc.png)

从`bomb.c`中可以看出:
- 如果`argc == 1`，即只在终端中输入`./bomb`时，需要在程序运行时以标准输入形式按行读入字符串；
- 否则如果`argc == 2`，即可通过文件名打开文件按行读入字符串；
- 总共有6个阶段，每个阶段命名为: `phase_x, x = 1 ~ 6`；

为了方便查看汇编代码，使用`objdump`获得反汇编文件:

```bash
objdump -d bomb > outdump.s
```

### phase_1

![phase_1](./pic/p1.png)

这段汇编逻辑很简单:

栈上开辟空间后，将`$0x402400`传入`%esi`，随后调用函数`<string_not_equal>`。从字面意思来看应该就是判断我们输入的字符串和答案字符串是否相等。

最后检查返回值`%eax`是否为0，为0则退栈，不为0则调用函数`<explode_bomb>`。

上面传入`%esi`寄存器的应该是一个地址，那么在`gdb`中查看一下这个地址所存储的字符串:

![ans_phase_1](./pic/ans_p1.png)

答案已经出来了: 

```
Border relations with Canada have never been better.
```

再运行`./bomb`测试一下：

![passp1](./pic/p1solved.png)

### phase_2

![phase_2](./pic/p2.png)

前4行汇编代码都是为进入`phase_2`函数做准备，在第5行进入函数`<read_six_numbers>`，那么就进入这个函数看看:

![read_six_numbers](./pic/r6num.png)

第805行:
```x86asm
sub $0x18, %rsp
```
这段代码含义为将栈指针`%rsp`向下移动`$0x18`个单位，即24B。很明显，这是在为栈上传递参数做准备。继续往下看，可以看出，从806-813行，均是在进行寄存器与栈上的传值，暂时看不出什么端倪。

但在814行有了些特殊的信息:
```x86asm
mov $0x4025c3, %esi
```
与`phase_1`一样，这儿也出现了一个类似于地址的值`0x4025c3`，借助于`phase_1`的经验，赶紧看看这个地址里存储了什么:

![check_0x4025c3](./pic/check_0x4025c3.png)

结合函数名称已经明白，此处是要输入6个整数，每个整数的类型为`int`，再结合805行的汇编语句，很明显此处开辟的栈空间为:
```
0x18 = 6 * 4B = 24B  
```
再结合815-817行，可知此时为调用库函数`scanf`进行6个整数的读入，`%eax`作为返回值，若`%eax > 5`，则退栈回到`<phase_2>`函数，否则调用`<explode_bomb>`函数引爆炸弹。

此时回到`phase_2`，随便输入6个整数:1 2 3 4 5 6，在执行完`<read_six_numbers>`函数后，查看一下栈上6个数字的存储情况:

![123456](./pic/123456.png)

此处已经完成了我们输入的6个整数的存储，其存储地址分别为

```x86asm
%rsp, %rsp+4, ... , %rsp+20
```
再回到`phase_2`，梳理从第362-368行的汇编语句可以写出如下对应的伪代码:
```c
0000000000400efc <phase_2>:
...
400f0a: 83 3c 24 01    cmpl   $0x1,(%rsp)
if(stack[%rsp] == 1)

400f0e: 74 20          je  400f30<phase_2+0x34>
jump to:
	0x400f30;

400f10: e8 25 05 00 00 call 40143a<explode_bomb>
400f15: eb 19          jmp  400f30<phase_2+0x34>

400f17: 8b 43 fc       mov    -0x4(%rbx),%eax
%eax = stack[%rbx - 4];

400f1a: 01 c0          add    %eax,%eax
%eax += %eax;

400f1c: 39 03          cmp    %eax,(%rbx)
if(%eax == stack[%rbx])

400f1e: 74 05          je   400f25<phase_2+0x29>
jump to:
	0x400f25;
	
400f20: e8 15 05 00 00 call 40143a<explode_bomb>
400f25: 48 83 c3 04    add    $0x4,%rbx
%rbx += 4;				// 继续往上比较输入的数字

400f29: 48 39 eb       cmp    %rbp,%rbx
400f2c: 75 e9          jne  400f17<phase_2+0x1b>
400f2e: eb 0c          jmp  400f3c<phase_2+0x40>
if((%rbp - %rbx) != 0)
	jump to:
		0x400f17;
return;

400f30: 48 8d 5c 24 04 lea    0x4(%rsp),%rbx
%rbx = %rsp + 4;		//(此处存储输入的第2个数字)

400f35: 48 8d 6c 24 18 lea    0x18(%rsp),%rbp
%rbp = %rsp + 0x18;		//(循环结束的边界地址)

400f3a: eb db          jmp  400f17<phase_2+0x1b>
jump to:
	0x400f17
...
```
可以看出，这段代码是在进行这样的一段逻辑:

最开始判断存储的第1个数字`(%rsp)`是不是1，如果不是1，直接引爆炸弹。如果是1，则往下依次比较存储的6个数字。在比较过程中，`%eax`从1开始进行自加，实际上`%eax`在每次比较过程中的值即为:
```
1 2 4 8 16 32
```
所以，可以得出`phase_2`的答案的6个数字为:

1 2 4 8 16 32

进行验证:

![passp2](./pic/p2solved.png)

### phase_3

首先还是进入`phase_3`查看汇编代码：

-----图片-----

很明显容易注意到，385-386两行是将栈指针`%rsp+8`与`%rsp+12`分别赋值给了`%rcx`与`%rdx`，凭借在《CSAPP》中学到的知识，可以猜测应该是通过栈来传递参数，不过此时无法确定，还需往后继续阅读。

此时同样出现了一个神秘地址`0x4025cf`，与`phase_1`、`phase_2`一样，查看一下该地址的内容:

-----图片-----

发现是要求输入两个整数，这印证了我们之前的猜想。继续读代码，从390-418行这一段代码，看起来有些复杂，但拿笔在纸上按行模拟一下也不难理解其中逻辑:

-----图片-----

```x86asm
cmp		$0x1, %eax
jg		400f6a,	<phase_3+0x27>
call 	40143a	<explode_bomb>
```
我们知道`%eax`一般作为函数返回值，所以以上三行实际上就是在判断对于上一个函数调用`(scanf)`所读入的参数个数是否大于1(两个整数)，如果不大于1，就调用函数`<explode_bomb>`，否则跳转到`0x400f6a`处。

随后从393-418行的代码实际上是在进行如下的逻辑: 首先比较输入的第一个数字是否大于7，如果大于7则引爆炸弹，否则根据第一个数字的值，来选择应该比较的第二个参数的值，其中有一行代码值得注意:

```x86asm
...
jmp		*0x402470(, %rax, 8)
...
```
此处进行的是间接寻址，形式地址为`0x402470 + %rax * 8`，而真正的逻辑地址为`[0x402470 + %rax*8]`。分别尝试对`%rax`赋值0 - 7，获得的逻辑地址如图所示:

-----图片-----

可以看见逻辑地址均为393-414行中的代码地址一一对应，对于其中的
```
mov	$0x??, %eax
```
选择对应的0 - 7中的数字进行尝试，结果正确:

-----图片-----

所以`phase_3`总共有8组答案，每组两个数字:

-----图片-----

### phase_4

![phase_4](./pic/phase_4.png)

首先同之前的`phase_x`一样给出该阶段的汇编代码，可以看到449行一样出现了一个神秘地址`0x4025cf`，不用多说，直接打印该地址中存储的内容:

![check_0x4025cf](./pic/p4-check.png)

所以可以得知，该阶段是要求读入两个整数(从451-453行也可以知道，`%eax`作为返回值的寄存器，统计输入数字个数，如果不等于2就跳转到`<explode_bomb>`函数处)。继续读汇编代码，453行:

```x86asm
...
cmpl	$0xe,		0x8(%rsp)
jbe		40103a	<phase_4+0x2e>
call	40143a	<explode_bomb>
...
```

`0x8(%rsp)`处存储的是我们输入的第一个数字，从这三行代码可以得知，第一个输入的数字必须小于`0xe`，不然的话就会直接引爆炸弹。继续往下阅读，可以看到在初始化`%edx、%esi、%edi`后转入`<func4>`函数，进入`<func4>`继续阅读:

![func4](./pic/func4.png)

初步阅读之后可以发现这是一个结合了分支选择和递归调用的函数，单步执行观察寄存器值变化并不合适弄清楚这个函数的行为。于是考虑逆向获得该函数的类C代码，类C代码编写如下:

![func4-c](./pic/func4-c.png)

阅读该代码可以得知，控制函数行为起主要作用的是`%ecx、%edi`寄存器，而后者刚好就是我们输入的第一个参数。进入`<func4>`，执行2-4行代码后，`%edx`值变为7，所以此时有两种分支选择:

- 若`%edi > 7`: 会进入内层`else`，并且在最终退出递归时`%eax`值恒不等于0;
- 若`%edi <= 7`: 会进入内层`if`(当`%edi = 7`时直接return)，或进入外层`else`，此时会多次递归进入`<func4>`。经过模拟试验，在递归进入后想要跳出递归且保持`%eax = 0`，`%edi`的值需为:

```
7, 3, 1, 0
```

再结合`phase_4`中463-465行代码:

```x86asm
...
cmpl	$0x0,	0xc(%rsp)
je		40105d	<phase_4+0x51>
call	40143a	<explode_bomb>
...
```

可以得知，输入的第二个参数必须为0，否则会引爆炸弹。

选择一个数作为第一个参数运行`./bomb`试验:

![passp4](./pic/passp4.png)







