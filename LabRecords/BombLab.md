
# Bomb Lab

`bomb.tar`中提供了如下文件:

- `bomb` (二进制可执行文件)
- `bomb.c` (bomb的C程序文件)
- `README`

尝试直接运行可执行文件`./bomb`，结果直接就炸了，还是从C程序文件读起吧。

![bomb.c](./pic/sc.png)

从`bomb.c`中可以看出:
- 如果`argc == 1`，即只在终端中输入`./bomb`时，需要在程序运行时以标准输入形式按行读入字符串；
- 否则如果`argc == 2`，即可通过文件名打开文件按行读入字符串；
- 总共有6个阶段，每个阶段命名为: `phase_x, x = 1 ~ 6`；

为了方便查看汇编代码，使用`objdump`获得反汇编文件:

```bash
objdump -d bomb > outdump.s
```

### phase_1

![phase_1](./pic/p1.png)

这段汇编逻辑很简单:

栈上开辟空间后，将`$0x402400`传入`%esi`，随后调用函数`<string_not_equal>`。从字面意思来看应该就是判断我们输入的字符串和答案字符串是否相等。

最后检查返回值`%eax`是否为0，为0则退栈，不为0则调用函数`<explode_bomb>`。

上面传入`%esi`寄存器的应该是一个地址，那么在`gdb`中查看一下这个地址所存储的字符串:

![ans_phase_1](./pic/ans_p1.png)

答案已经出来了: 

```
Border relations with Canada have never been better.
```

再运行`./bomb`测试一下：

![passp1](./pic/p1solved.png)

### phase_2

![phase_2](./pic/p2.png)

前4行汇编代码都是为进入`phase_2`函数做准备，在第5行进入函数`<read_six_numbers>`，那么就进入这个函数看看:

![read_six_numbers](./pic/r6num.png)

第805行:
```x86asm
sub $0x18, %rsp
```
这段代码含义为将栈指针`%rsp`向下移动`$0x18`个单位，即24B。很明显，这是在为栈上传递参数做准备。继续往下看，可以看出，从806-813行，均是在进行寄存器与栈上的传值，暂时看不出什么端倪。

但在814行有了些特殊的信息:
```x86asm
mov $0x4025c3, %esi
```
与`phase_1`一样，这儿也出现了一个类似于地址的值`0x4025c3`，借助于`phase_1`的经验，赶紧看看这个地址里存储了什么:

![check_0x4025c3](./pic/check_0x4025c3.png)

结合函数名称已经明白，此处是要输入6个整数，每个整数的类型为`int`，再结合805行的汇编语句，很明显此处开辟的栈空间为:
```
0x18 = 6 * 4B = 24B  
```
再结合815-817行，可知此时为调用库函数`scanf`进行6个整数的读入，`%eax`作为返回值，若`%eax > 5`，则退栈回到`<phase_2>`函数，否则调用`<explode_bomb>`函数引爆炸弹。

此时回到`phase_2`，随便输入6个整数:1 2 3 4 5 6，在执行完`<read_six_numbers>`函数后，查看一下栈上6个数字的存储情况:

![123456](./pic/123456.png)

此处已经完成了我们输入的6个整数的存储，其存储地址分别为

```x86asm
%rsp, %rsp+4, ... , %rsp+20
```
再回到`phase_2`，梳理从第362-368行的汇编语句可以写出如下对应的伪代码:
```c
0000000000400efc <phase_2>:
...
400f0a: 83 3c 24 01    cmpl   $0x1,(%rsp)
if(stack[%rsp] == 1)

400f0e: 74 20          je  400f30<phase_2+0x34>
jump to:
	0x400f30;

400f10: e8 25 05 00 00 call 40143a<explode_bomb>
400f15: eb 19          jmp  400f30<phase_2+0x34>

400f17: 8b 43 fc       mov    -0x4(%rbx),%eax
%eax = stack[%rbx - 4];

400f1a: 01 c0          add    %eax,%eax
%eax += %eax;

400f1c: 39 03          cmp    %eax,(%rbx)
if(%eax == stack[%rbx])

400f1e: 74 05          je   400f25<phase_2+0x29>
jump to:
	0x400f25;
	
400f20: e8 15 05 00 00 call 40143a<explode_bomb>
400f25: 48 83 c3 04    add    $0x4,%rbx
%rbx += 4;				// 继续往上比较输入的数字

400f29: 48 39 eb       cmp    %rbp,%rbx
400f2c: 75 e9          jne  400f17<phase_2+0x1b>
400f2e: eb 0c          jmp  400f3c<phase_2+0x40>
if((%rbp - %rbx) != 0)
	jump to:
		0x400f17;
return;

400f30: 48 8d 5c 24 04 lea    0x4(%rsp),%rbx
%rbx = %rsp + 4;		//(此处存储输入的第2个数字)

400f35: 48 8d 6c 24 18 lea    0x18(%rsp),%rbp
%rbp = %rsp + 0x18;		//(循环结束的边界地址)

400f3a: eb db          jmp  400f17<phase_2+0x1b>
jump to:
	0x400f17
...
```
可以看出，这段代码是在进行这样的一段逻辑:

最开始判断存储的第1个数字`(%rsp)`是不是1，如果不是1，直接引爆炸弹。如果是1，则往下依次比较存储的6个数字。在比较过程中，`%eax`从1开始进行自加，实际上`%eax`在每次比较过程中的值即为:
```
1 2 4 8 16 32
```
所以，可以得出`phase_2`的答案的6个数字为:

1 2 4 8 16 32

进行验证:

![passp2](./pic/p2solved.png)

### phase_3

```
phase_3图片暂时未补充，等待后续上传
```

首先还是进入`phase_3`查看汇编代码：

-----图片-----

很明显容易注意到，385-386两行是将栈指针`%rsp+8`与`%rsp+12`分别赋值给了`%rcx`与`%rdx`，凭借在《CSAPP》中学到的知识，可以猜测应该是通过栈来传递参数，不过此时无法确定，还需往后继续阅读。

此时同样出现了一个神秘地址`0x4025cf`，与`phase_1`、`phase_2`一样，查看一下该地址的内容:

-----图片-----

发现是要求输入两个整数，这印证了我们之前的猜想。继续读代码，从390-418行这一段代码，看起来有些复杂，但拿笔在纸上按行模拟一下也不难理解其中逻辑:

-----图片-----

```x86asm
cmp		$0x1, %eax
jg		400f6a,	<phase_3+0x27>
call 	40143a	<explode_bomb>
```
我们知道`%eax`一般作为函数返回值，所以以上三行实际上就是在判断对于上一个函数调用`(scanf)`所读入的参数个数是否大于1(两个整数)，如果不大于1，就调用函数`<explode_bomb>`，否则跳转到`0x400f6a`处。

随后从393-418行的代码实际上是在进行如下的逻辑: 首先比较输入的第一个数字是否大于7，如果大于7则引爆炸弹，否则根据第一个数字的值，来选择应该比较的第二个参数的值，其中有一行代码值得注意:

```x86asm
...
jmp		*0x402470(, %rax, 8)
...
```
此处进行的是间接寻址，形式地址为`0x402470 + %rax * 8`，而真正的逻辑地址为`[0x402470 + %rax*8]`。分别尝试对`%rax`赋值0 - 7，获得的逻辑地址如图所示:

-----图片-----

可以看见逻辑地址均为393-414行中的代码地址一一对应，对于其中的
```
mov	$0x??, %eax
```
选择对应的0 - 7中的数字进行尝试，结果正确:

-----图片-----

所以`phase_3`总共有8组答案，每组两个数字:

-----图片-----

### phase_4

![phase_4](./pic/phase_4.png)

首先同之前的`phase_x`一样给出该阶段的汇编代码，可以看到449行一样出现了一个神秘地址`0x4025cf`，不用多说，直接打印该地址中存储的内容:

![check_0x4025cf](./pic/p4-check.png)

所以可以得知，该阶段是要求读入两个整数(从451-453行也可以知道，`%eax`作为返回值的寄存器，统计输入数字个数，如果不等于2就跳转到`<explode_bomb>`函数处)。继续读汇编代码，453行:

```x86asm
...
cmpl	$0xe,		0x8(%rsp)
jbe		40103a	<phase_4+0x2e>
call	40143a	<explode_bomb>
...
```

`0x8(%rsp)`处存储的是我们输入的第一个数字，从这三行代码可以得知，第一个输入的数字必须小于`0xe`，不然的话就会直接引爆炸弹。继续往下阅读，可以看到在初始化`%edx、%esi、%edi`后转入`<func4>`函数，进入`<func4>`继续阅读:

![func4](./pic/func4.png)

初步阅读之后可以发现这是一个结合了分支选择和递归调用的函数，单步执行观察寄存器值变化并不合适弄清楚这个函数的行为。于是考虑逆向获得该函数的类C代码，类C代码编写如下:

![func4-c](./pic/func4-c.png)

阅读该代码可以得知，控制函数行为起主要作用的是`%ecx、%edi`寄存器，而后者刚好就是我们输入的第一个参数。进入`<func4>`，执行2-4行代码后，`%edx`值变为7，所以此时有两种分支选择:

- 若`%edi > 7`: 会进入内层`else`，并且在最终退出递归时`%eax`值恒不等于0;
- 若`%edi <= 7`: 会进入内层`if`(当`%edi = 7`时直接return)，或进入外层`else`，此时会多次递归进入`<func4>`。经过模拟试验，在递归进入后想要跳出递归且保持`%eax = 0`，`%edi`的值需为:

```
7, 3, 1, 0
```

再结合`phase_4`中463-465行代码:

```x86asm
...
cmpl	$0x0,	0xc(%rsp)
je		40105d	<phase_4+0x51>
call	40143a	<explode_bomb>
...
```

可以得知，输入的第二个参数必须为0，否则会引爆炸弹。

选择一个数作为第一个参数运行`./bomb`:

![passp4](./pic/passp4.png)

### phase_5

![phase_5-1](./pic/phase_5-1.png)
![phase_5-1](./pic/phase_5-2.png)

`phase_5`部分代码较长，比较合适的做法是先使用`gdb`单步执行指令，获得程序的大概执行过程后，逆向得出C程序代码再来理解。此处先不直接给出逆向最后的C代码，我们逐步来进行分析:

470-476行的代码是在进行“栈保护”，具体相关的知识可以从《CSAPP》第三章教材获得，该知识与本阶段要解决的问题关系不大，所以先不对这部分进行深究。

继续往后阅读，发现此时调用了函数`<string_length>`，由之前阶段可知，该函数用于统计输入中的字符个数，并且使用`%eax`寄存器作为返回值。返回的字符数要求为6，否则引爆炸弹。此处我们随意输入`123456`，继续往下执行。

经过两次地址跳转`0x4010d2 -> 0x40108b`后，`%eax`初始化为0，进入到482-490行的代码中:

```x86asm
...
movzbl	(%rbx, %rax, 1),	%ecx
mov			%cl,	(%rsp)
mov			(%rsp),	%rdx
and			$0xf,	%edx
movzbl	0x4024b0(%rdx),	%edx
mov			%dl,	0x10(%rsp, %rax, 1)
add			$0x1,	%rax
cmp			$0x6,	%rax
jne			40108b	<phase_5+0x29>
...
```

初步阅读可以知道，这是一个循环结构，以`%eax`作为循环跳出条件:
```
eax = 0;
while(eax != 6){
	...
	eax++;
}
```
此时我们的输入已经读入了程序，因为不清楚此时的寄存器值的情况，同时也确认一下我们的输入数据的存储位置，查看一下当前寄存器:

![check_regs](./pic/p5-chkr.png)

此时可以看见：
- `%eax`已经被初始化为0；
- `%rcx`值为6，应该是统计的是字符串中的字符个数；
- `%rbx = %rdi = %rsi = 0x6038c0`，这个值看起来没什么头绪，但是我们知道`%rdi`中存储的应该是我们的输入数据的相关信息；
- `%rdx = 0x6038c6 = 0x6038c0 + 6`，这个值看起来应该不是巧合，那么这个奇怪的数字必定与我们输入的数据有关。

进一步查看这几个寄存器相关信息:

![instr](./pic/p5instr.png)

可以得知，`%rbx, %rdi, %rsi`中存储的是输入字符串的地址，`%rdx`是输入字符串的末尾地址。继续后续的代码阅读，从482-487行模拟执行后可以知道这段代码的大致逻辑如下:

当`%rax != 6`时:

- 以`%rax`作为变址寄存器，`%rbx`作为基地址(输入字符串的首地址)进行寻址，每次获得输入字符串其中的一个字符`c`，获取字符`c`的字节表示(只取低8位，高位取0)后，与`0xf`相与。

- 再将结果加上`0x4024b0`后进行间址寻址送`%edx`，再对`%edx`取低8比特，送到内存地址为`(%rsp + %rax * 1 + 0x10)`处存储。

- `%rax`自增1。

此处出现了一个地址`0x4024b0`，直接查看其中内容:

![p5-0x4024b0](./pic/p5-0x4024b0.png)

继续往下阅读，在执行完491-494行代码可以得知，此时`%rdi`中存储的应该是我们输入的字符串经过上述变换操作后寻址得到的字符串，而`%esi`中存储的应该是答案字符串，此时调用`<strings_not_equal>`函数进行对比，通过返回值`%eax`是否为0来决定最终是否引爆炸弹。

查看`%rdi`与`%esi`寄存器中内容：

![p5-converted-str](./pic/p5-cstr.png)

进行验证，对于字符`1`，其ASCII码的二进制表示为`0011_0001`，取低4比特后加上偏移地址`0x4024b0`后查看内容:

![p5-0x4024b1](./pic/p5-0x4024b1.png)

其第一个字符确实为`a`，且按照此规则，后续的字符也与输入字符串相匹配。所以答案已经明了:

输入6个字符，每个字符的ASCII码表示的低4比特加上偏移地址`0x4024b0`后对给定字符串进行寻址，要求最终寻址得到的字符串为:

```
flyers
```

简单计算后可得出一个答案:

```
9?>567
```

输入验证:

![passp5](./pic/passp5.png)

### phase_6

![p6-1](./pic/p6-1.png)
![p6-2](./pic/p6-2.png)
![p6-3](./pic/p6-3.png)
![p6-4](./pic/p6-4.png)

- 512-521行是程序执行前的准备工作:

首先将寄存器原值压入栈中，随后开辟栈空间，调用`<read_six_numbers>`函数读入6个数字。不过此时要注意，`%r13, %r14, %rsi`均被赋值为了`%rsp`，即此时这三个寄存器均指向栈顶，这个信息十分关键，后续会多次用到。

- 522-542行:

对栈上存储的输入的6个数字逐一进行比较，要求每一个数字在减1之后小于等于5，否则引爆炸弹；且同时要求6个数字互不相等，否则也会引爆炸弹。

假设我们此处输入的数字是:`1 2 3 4 5 6`，可以打印栈指针查看输入的存储情况:

![p6-readin](./pic/p6-readin.png)

可以得知，输入的6个数字倒序存储在栈上，栈顶存储第1个输入的数字。

- 543-551行:

将`%rax`指向栈顶，将`%rsi`指向输入的6个数字末尾，作为循环退出条件。对于每一个输入的栈内数字`i`，`i = 7 - i`。

此时，我们输入的6个数字从栈顶往上依次被更改为:`6 5 4 3 2 1 `。

- 552-569行:

个人认为这一段代码是整个阶段中逻辑难度最大的一段代码，叙述过程比较麻烦，此处直接给出逆向之后得到的类C代码:

```c
/* c description of code in outdump.s from line 552 to 569 */
void func6(){
	esi = 0;
	ecx = *(rsp + rsi);	// 存储栈内数据，从栈顶开始
	while(rsi != 0x18)	// 0x18 = 24 = 4 * 6 
	{
		if(ecx > 1){
			eax = 1;
			edx = 0x6032d0;
			while(eax != ecx){
				rdx = *(rdx + 8);
				eax++;
			}
		}
		else{
			edx = 0x6032d0;
		}
		*(0x20 + rsp + rsi * 2) = rdx;
		rsi += 4;
		ecx = *(rsp + rsi);
	}
	return;
}
```

可以看出，这段代码的逻辑是从栈顶依次遍历每一个栈内数据存储到`%ecx`中，如果该数大于1，则从链表头节点开始进行`%ecx - 1`次循环，每次后移一个节点，指向节点的指针存储在`rdx`中。最后将计算结束之后的节点指针存储在`[0x20 + rsp + rsi * 2]`。

链表节点定义如下:

```c
struct node{
	unsigned long address;
	struct node* next;
}
```

- 570-591行:
这一段代码也稍微有点绕，具体注释请看代码:

```x86asm
...
mov    0x20(%rsp),%rbx				
//	rbx中存储按照输入数字变换之后的得到的指向第一个链表节点的指针

lea    0x28(%rsp),%rax
lea    0x50(%rsp),%rsi
// 	rax 与 rsi 中分别是存储指针的栈地址的开始与结束

mov    %rbx,%rcx
mov    (%rax),%rdx
mov    %rdx,0x8(%rcx)
add    $0x8,%rax
cmp    %rsi,%rax
je     4011d2 <phase_6+0xde>
mov    %rdx,%rcx
jmp    4011bd <phase_6+0xc9>
//	根据输入的数字顺序对链表进行重排，比如链表最初排列为:
//	node1 -> node2 -> node3 ... -> node6
//	假设我的输入数字是1，2，3，4，5，6，在经过前一步减7的操作后，栈上存储数字变为:
//	6，5，4，3，2，1(从栈顶开始)
//	则此时重排之后的链表序为:
//	node6 -> node5 -> ... -> node1

movq   $0x0,0x8(%rdx)
00 
mov    $0x5,%ebp
mov    0x8(%rbx),%rax
mov    (%rax),%eax
cmp    %eax,(%rbx)
jge    4011ee <phase_6+0xfa>
call   40143a <explode_bomb>
mov    0x8(%rbx),%rbx
//	对重排之后的链表进行大小判断，要求从当前的首节点开始，
//	任意一个节点中的数值均大于后一个节点数值
//	即链表中的数值排列应为单调递减

sub    $0x1,%ebp
jne    4011df <phase_6+0xeb>
add    $0x50,%rsp
//	ebp作为循环跳出条件，最后rsp退栈结束整个phase_6程序
...

```

有了上面的分析，现在需要做的事就是确定每一个链表节点中的数值大小，然后选择合适的顺序输入，使得经过数字变换与链表重排后，能够让链表为单调递减的序列。因为已知链表的节点结构与指向第一个链表节点的指针`%rbx`，我们可以依次获取后续每个节点指针与其存储的数值:

![p6-nodeval](./pic/p6-nodeval.png)

```c
node6	0x1bb
node5	0x1dd
node4	0x263
node3	0x39c
node2	0x0a8
node1	0x14c
```

所以经过简单计算，要输入的数字应该是:

```
4 3 2 1 6 5
```

输入验证:

![passp6](./pic/passp6.png)

















