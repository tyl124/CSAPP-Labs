# CacheLab

## Part 1
实现一个组相连结构的`cache`模拟器，运行时可以在命令行中指定组数/块偏移/组内行数，程序构成如下:

```c 
main(): 处理命令行参数，随后调用相关函数完成模拟

init_cache(): 初始化cache

simulate(): 模拟整个的cache访问过程
```

其中，对于每个函数，又有不同的细分任务:
```c
init_cache():
1. 设置cache的：行数 / 块大小 / 组数；
2. 对于每一个cache行，动态分配内存，并且将每一个cache行的信息(有效位 / 标记 / 时间戳记号)都进行初始化.

simulate():
1. 从trace文件中按行读取操作与参数；
2. 根据不同的操作，选择相应的访问cache行为.
```

在`simulate()`中，考虑将访问`cache`的行为单独抽离出来编写新的函数实现:

```c
access_cache():
1. 根据传入的标记和组号进行查询；
2. 如果命中，命中计数加1，同时对该块进行更新；
3. 如果不命中，寻找空块进行替换：
	- 如果存在空块，直接装入；
	- 如果不存在空块，使用LRU()算法替换已有块.

update():
1. 更新操作首先将访问块的有效位和标记位更新；
2. 对其他块的时间戳记号加1；
3. 本块的时间戳归0，表示为最新访问块.

is_full(): 遍历对应组的所有块，是否存在有效位为0的块即可.

LRU(): 遍历对应组的所有块，寻找时间戳标记最大块即可.

```

完整实现代码请查看github仓库.

## Part 2